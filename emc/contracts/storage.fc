;; Storage layout:
;; root cell contains:
;; owner:MsgAddress
;; operator:MsgAddress
;; fee_receiver:MsgAddress
;; fee_bps:uint16
;; enabled:int1
;; sessions:dict(session_id:uint64 -> SessionCell)
;; principal:dict(hash -> uint128)
;; fees:dict(hash -> uint128)

global slice g_owner;
global slice g_operator;
global slice g_fee_receiver;

global int g_fee_bps;
global int g_enabled;

;; In FunC, dictionaries are stored as cells
global cell g_sessions;
global cell g_principal;
global cell g_fees;
global cell g_wallets;

() load_storage() impure {
  slice ds = get_data().begin_parse();

  g_owner        = ds~load_msg_addr();
  g_operator     = ds~load_msg_addr();
  g_fee_receiver = ds~load_msg_addr();

  g_fee_bps      = ds~load_uint(16);
  g_enabled      = ds~load_uint(1);

  g_sessions     = ds~load_dict();
  g_principal    = ds~load_dict();
  g_fees         = ds~load_dict();
  g_wallets      = ds~load_dict();
  
  ds.end_parse();
}

() save_storage() impure {
  builder b = begin_cell();

  b.store_slice(g_owner);
  b.store_slice(g_operator);
  b.store_slice(g_fee_receiver);

  b.store_uint(g_fee_bps, 16);
  b.store_uint(g_enabled, 1);

  b.store_dict(g_sessions);
  b.store_dict(g_principal);
  b.store_dict(g_fees);
  b.store_dict(g_wallets);

  set_data(b.end_cell());
}

;; Session cell format:
;; active:uint1
;; pool:MsgAddress
;; input_jetton_master:MsgAddress
;; created_at:uint64
;; has_pending:uint1
;; if has_pending:
;;    swap_id:uint64
;;    amount_in:uint128
;;    fee:uint128
;;    jetton_master:MsgAddress
;;    created_at:uint64

(cell) pack_session(
  int active,
  slice pool,
  slice input_jetton,
  int created_at,
  int has_pending,
  int swap_id,
  int amount_in,
  int fee,
  slice pending_jetton,
  int pending_at
) inline {
  builder b = begin_cell();
  b.store_uint(active, 1);
  b.store_slice(pool);
  b.store_slice(input_jetton);
  b.store_uint(created_at, 64);

  b.store_uint(has_pending, 1);
  if (has_pending) {
    b.store_uint(swap_id, 64);
    b.store_uint(amount_in, 128);
    b.store_uint(fee, 128);
    b.store_slice(pending_jetton);
    b.store_uint(pending_at, 64);
  }
  return b.end_cell();
}

(int, slice, slice, int, int, int, int, int, slice, int) unpack_session(cell c) inline {
  slice s = c.begin_parse();
  int active = s~load_uint(1);
  slice pool = s~load_msg_addr();
  slice input_jetton = s~load_msg_addr();
  int created_at = s~load_uint(64);

  int has_pending = s~load_uint(1);
  int swap_id = 0;
  int amount_in = 0;
  int fee = 0;
  slice pending_jetton = null(); ;; Initialize as null
  int pending_at = 0;

  if (has_pending) {
    swap_id = s~load_uint(64);
    amount_in = s~load_uint(128);
    fee = s~load_uint(128);
    pending_jetton = s~load_msg_addr();
    pending_at = s~load_uint(64);
  }

  return (active, pool, input_jetton, created_at, has_pending, swap_id, amount_in, fee, pending_jetton, pending_at);
}

(cell) get_session_cell(int session_id) inline {
  ;; udict_get_ref? is the correct function to get a cell from a 64-bit uint key
  var (val, ok) = g_sessions.udict_get_ref?(64, session_id);
  req(ok, ERR_SESSION_NOT_FOUND);
  return val;
}

() put_session_cell(int session_id, cell c) inline {
  ;; udict_set_ref modifies the dict by adding the cell under the 64-bit key
  g_sessions~udict_set_ref(64, session_id, c);
}